{"/home/travis/build/npmtest/node-npmtest-cluster-service/test.js":"/* istanbul instrument in package npmtest_cluster_service */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cluster-service/lib.npmtest_cluster_service.js":"/* istanbul instrument in package npmtest_cluster_service */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cluster_service = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cluster_service = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cluster-service/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cluster-service && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cluster_service */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cluster_service\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cluster_service.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cluster_service.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cluster_service.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cluster_service.__dirname + '/lib.npmtest_cluster_service.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/cluster-service.js":"var cluster = require(\"cluster\");\nvar colors = require(\"colors\");\nif (!('cservice' in global)) {\n  global.cservice = { locals: require(\"./lib/defaults\") };\n}\n\nmodule.exports = exports;\n\nexports.debug = require(\"./lib/util\").debug;\nexports.log = require(\"./lib/util\").log;\nexports.error = require(\"./lib/util\").error;\nexports.results = require(\"./lib/util\").results;\nexports.processSafeSend = require(\"./lib/util\").processSafeSend;\nexports.msgBus = require(\"./lib/message-bus\");\n\nexports.workerReady = require(\"./lib/worker-ready\");\n\nObject.defineProperty(exports, \"workers\", {\n  get: require(\"./lib/workers\").get\n});\n\nObject.defineProperty(exports, \"isMaster\", {\n  get: function() {\n    return cluster.isMaster;\n  }\n});\n\nObject.defineProperty(exports, \"isWorker\", {\n  get: function() {\n    return cluster.isWorker;\n  }\n});\n\nObject.defineProperty(exports, \"options\", {\n  get: function() {\n    return global.cservice.locals.options;\n  }\n});\n\nObject.defineProperty(exports, \"locals\", {\n  get: function() {\n    return global.cservice.locals;\n  }\n});\n\nif (cluster.isMaster === true) {\n  exports.control = require(\"./lib/control\").addControls;\n  exports.stop = require(\"./lib/stop\");\n  exports.newWorker = require(\"./lib/new-worker\");\n  exports.on = require(\"./lib/commands\").on;\n  exports.registerCommands = require(\"./lib/commands\").register;\n} else {\n  exports.on = function() { };\n  exports.registerCommands = function() { };\n}\n\nexports.trigger = require(\"./lib/trigger\");\nexports.start = require(\"./lib/start\");\nexports.netServers = require(\"./lib/net-servers\");\nexports.netStats = require(\"./lib/net-stats\");\nexports.proxy = require('./lib/proxy');\n\nif (\n  cluster.isWorker === true\n  && typeof (cluster.worker.module) === \"undefined\"\n){\n  // intermediate state to prevent 2nd call while async in progress\n  cluster.worker.module = {};\n  cluster.worker.env = process.env;\n\n  var workers = require(\"./lib/workers\");\n\n  workers.demote();\n\n  // load the worker if not already loaded\n  // async, in case worker loads cluster-service, we need to return before\n  // it's avail\n  setImmediate(function() {\n    cluster.worker.module = require(process.env.worker);\n    if (global.cservice.locals.workerReady === undefined\n      && process.env.ready.toString() === \"false\") {\n      // if workerReady not invoked explicitly, we'll track it automatically\n      exports.workerReady(false);\n      exports.netServers.waitForReady(function() {\n        exports.workerReady(); // NOW we're ready\n      });\n    }\n  });\n\n  // start worker monitor to establish two-way relationship with master\n  workers.monitor();\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/defaults.js":"var os = require(\"os\");\n\nmodule.exports = exports = {\n  firstTime: true,\n  events: {},\n  workers: {},\n  workerProcesses: {},\n  state: 0, // 0-not running, 1-starting, 2-running\n  isBusy: false,\n  isAttached: false, // attached to CLI over REST\n  workerReady: undefined,\n  restartOnFailure: true,\n  net: { servers: {} },\n  proxy: {\n    configPath: undefined,\n    versionPath: undefined,\n    options: {\n      versionPath: undefined,\n      versionHeader: \"x-version\",\n      workerFilename: \"worker.js\",\n      versionPorts: \"11000-12000\",\n      nonDefaultWorkerCount: 1,\n      nonDefaultWorkerIdleTime: 3600,\n      bindings: [\n        /*\n         {\n           port: 80,\n           workerCount: 2,\n           redirect: 443\n         },\n         {\n           port: 443,\n           workerCount: 2,\n           tlsOptions: {\n             key: '/my/cert.key',\n             cert: '/my/cert.crt'\n           }\n         }\n         */\n      ]\n    },\n    versions: {\n    /*\n      'versionStr': {\n        port: 7112,\n        isDefault: false,\n        online: false\n      }\n    */\n    }\n  },\n  options: {\n    host: \"localhost\",\n    port: 11987,\n    accessKey: undefined,\n    workers: undefined,\n    workerCount: os.cpus().length,\n    restartDelayMs: 100,\n    restartConcurrencyRatio: 0.33,\n    allowHttpGet: false, // useful for testing -- not safe for production use\n    restartsPerMinute: 10, // not yet supported\n    cli: false,\n    silent: false,\n    log: console.log,\n    error: console.error,\n    debug: console.debug,\n    json: false, // output as JSON\n    restartOnMemUsage: undefined,\n    restartOnUpTime: undefined,\n    commands: undefined,\n    proxy: undefined,\n    workerGid: undefined,\n    workerUid: undefined,\n    colors: {\n      cservice: \"grey\",\n      success: \"green\",\n      error: \"red\",\n      data: \"cyan\",\n      warn: \"yellow\",\n      info: \"magenta\",\n      debug: \"grey\"\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/util.js":"var cservice = require(\"../cluster-service\");\n\n/*\n * question - Question to split apart.\n Ex: prop1 \"prop #2\" { \"prop\": 3 } [ \"prop #4\" ] 5\n * delimiter - What splits the properties? Can be one or more characters.\n * return - An array of arguments.\n Ex: [ \"prop1\", \"prop #2\", { \"prop\": 3 }, [ \"prop #4\" ], 5 ]\n */\nexports.getArgsFromQuestion = getArgsFromQuestion;\nexports.debug = debug;\nexports.log = log;\nexports.error = error;\nexports.results = results;\nexports.processSafeSend = processSafeSend;\n\nfunction debug() {\n  var args;\n  var i;\n  if (cservice.options.cli === true && cservice.options.debug) {\n    if(process.stdout.clearLine){\n      process.stdout.clearLine();\n    }\n    if(process.stdout.cursorTo){\n      process.stdout.cursorTo(0);\n    }\n\n    args = Array.prototype.slice.call(arguments);\n    for (i = 0; i < args.length; i++) {\n      if (typeof args[i] === \"string\") {\n        args[i] = args[i].debug;\n      }\n    }\n    if (args.length > 0 && typeof args[0] === \"string\" && args[0][0] === \"{\") {\n      cservice.options.debug(\"cservice:\".cservice);\n    } else {\n      args = [\"cservice: \".cservice].concat(args);\n    }\n    cservice.options.debug.apply(this, args);\n  }\n}\n\nfunction log() {\n  var args;\n  if (cservice.options.cli === true && cservice.options.log) {\n    if(process.stdout.clearLine){\n      process.stdout.clearLine();\n    }\n    if(process.stdout.cursorTo){\n      process.stdout.cursorTo(0);\n    }\n\n    args = Array.prototype.slice.call(arguments);\n    if (args.length > 0 && typeof args[0] === \"string\" && args[0][0] === \"{\") {\n      cservice.options.log(\"cservice:\".cservice);\n    } else {\n      args = [\"cservice: \".cservice].concat(args);\n    }\n    cservice.options.log.apply(this, args);\n  }\n}\n\nfunction error() {\n  var args;\n  var i;\n  if (cservice.options.cli === true && cservice.options.error) {\n    if(process.stdout.clearLine){\n      process.stdout.clearLine();\n    }\n    if(process.stdout.cursorTo){\n      process.stdout.cursorTo(0);\n    }\n\n    args = Array.prototype.slice.call(arguments);\n    for (i = 0; i < args.length; i++) {\n      if (typeof args[i] === \"string\") {\n        args[i] = args[i].error;\n      }\n    }\n    if (args.length > 0 && typeof args[0] === \"string\" && args[0][0] === \"{\") {\n      cservice.options.error(\"cservice:\".cservice);\n    } else {\n      args = [\"cservice: \".cservice].concat(args);\n    }\n    cservice.options.error.apply(this, args);\n  }\n}\n\nfunction results() {\n  if(cservice.options.log){\n    cservice.options.log.apply(this, arguments);\n  }\n}\n\nfunction getArgsFromQuestion(question, delimiter) {\n\n  // OLD WAY - simply breaks args by delimiter\n  //var split = question.split(\" \");\n  //var args = [split[0], onCallback].concat(split.slice(1));\n\n  // parser needs to be smarter, to account for various data types:\n  // single word strings: hello\n  // phrases: \"hello world\"\n  // numbers: 1 or 1.3\n  // JSON: [] or { \"a\": { \"b\": \"hello \\\"world\\\"\" } }\n  var arg = []\n    , args = []\n    , stringOpen = false\n    , jsonLevel = 0\n    , arrayLevel = 0\n    , i\n    , isDelim\n    , c\n    , cprev\n    , cnext;\n\n  for (i = 0; i < question.length; i++) {\n    cprev = i > 0 ? question[i - 1] : \"\";\n    c = question[i];\n    cnext = (i < question.length - 1) ? question[i + 1] : \"\";\n    isDelim = (c === delimiter);\n    if (stringOpen === true) { // processing quotted string\n      if (c === \"\\\"\" && cprev !== \"\\\\\") { // closer\n        // close string\n        stringOpen = false;\n        // add string arg, even if empty\n        args.push(getArgFromValue(arg.join(\"\")));\n        // reset arg\n        arg = [];\n      } else { // just another char\n        arg.push(c);\n      }\n    } else if (jsonLevel > 0) { // processing JSON object\n      if (c === \"}\" && cprev !== \"\\\\\") { // closer\n        jsonLevel--;\n      } else if (c === \"{\" && cprev !== \"\\\\\") { // opener\n        jsonLevel++;\n      }\n\n      arg.push(c);\n\n      if (jsonLevel === 0) { // closed\n        args.push(getArgFromValue(arg.join(\"\")));\n        // reset arg\n        arg = [];\n      }\n    } else if (arrayLevel > 0) { // processing JSON object\n      if (c === \"]\" && cprev !== \"\\\\\") { // closer\n        arrayLevel--;\n      } else if (c === \"[\" && cprev !== \"\\\\\") { // opener\n        arrayLevel++;\n      }\n\n      arg.push(c);\n\n      if (arrayLevel === 0) { // closed\n        args.push(getArgFromValue(arg.join(\"\")));\n        // reset arg\n        arg = [];\n      }\n    } else { // processing basic arg\n      if (c === delimiter) { // delimiter\n        if (arg.length > 0) { // if arg, add it\n          args.push(getArgFromValue(arg.join(\"\")));\n          // reset arg\n          arg = [];\n        }\n      } else if (c === \"{\" && arg.length === 0) { // JSON opener\n        jsonLevel++;\n        arg.push(c);\n      } else if (c === \"[\" && arg.length === 0) { // Array opener\n        arrayLevel++;\n        arg.push(c);\n      } else if (c === \"\\\"\" && arg.length === 0) { // string opener\n        stringOpen = true;\n      } else { // add it\n        arg.push(c);\n      }\n    }\n  }\n\n  if (arg.length > 0) { // if arg remains, add it too\n    args.push(getArgFromValue(arg.join(\"\")));\n  }\n\n  return args;\n}\n\nfunction getArgFromValue(val) {\n  try {\n    // \\\" tags should be standard quotes after parsed\n    val = val.replace(/\\\\\\\"/g, '\"');\n\n    // try to process as JSON first\n    // Typical use cases:\n    // 1 - number\n    // 1.3 - number\n    // [] - array\n    // { \"a\": { } } - object\n    return JSON.parse(val);\n  } catch (ex) {\n    return val; // use as-is\n  }\n}\n\nfunction processSafeSend(process, msg) {\n  try {\n    process.send(msg);\n  } catch (ex) {\n    return ex;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/message-bus.js":"var cservice = require(\"../cluster-service\");\nvar util = require(\"util\");\nvar cluster = require(\"cluster\");\nvar async = require(\"async\");\n\nmodule.exports = {\n  createMessage: createMessage,\n  sendMessage: sendMessage,\n  isValidMessage: isValidMessage,\n  respondToMessage: respondToMessage,\n  processMessage: processMessage\n};\n\nvar waiters = {};\nvar waiterId = 0;\n\nfunction isValidMessage(msg) {\n  if (!msg || !msg.cservice || !msg.cservice.cmd) {\n    return false; // ignore invalid cluster-service messages\n  }\n\n  return true;\n}\n\nfunction createMessage(cmd, options) {\n  var msg = {\n    cservice: util._extend({}, options || {})\n  };\n  msg.cservice.cmd = cmd;\n  return msg;\n}\n\nfunction sendMessage(cmd, options, filter, cb) {\n  var msg = createMessage(cmd, options);\n\n  if (cluster.isWorker === true) {\n    createWaiter(msg, process, cb);\n    // send to master and wait for response\n    return cservice.processSafeSend(process, msg);\n  }\n\n  var workers = cluster.workers;\n  if (typeof filter === \"function\") {\n    // filter as directed\n    workers = workers.filter(filter);\n  }\n\n  var tasks = [];\n\n  workers.forEach(function(worker) {\n    tasks.push(createWaiterTask(msg, worker.process, cb));\n  });\n\n  // process worker messages, but callback only once\n  async.parallel(tasks, function (err, data) {\n    if (typeof cb === \"function\") {\n      cb(err, data);\n    }\n  });\n}\n\nfunction createWaiter(msg, process, cb) {\n  if (typeof cb !== \"function\") {\n    return;\n  }\n\n  msg.waiterId = \"id\" + (++waiterId);\n  var waiter = waiters[msg.waiterId] = {\n    msg: msg,\n    process: process,\n    cb: cb\n  };\n\n  return waiter;\n}\n\nfunction createWaiterTask(msg, process) {\n  return function(asyncCb) {\n    var waiter = createWaiter(msg, process, asyncCb);\n    cservice.processSafeSend(process, msg);\n    if (!waiter) {\n      // if no waiter, cb immediately\n      asyncCb();\n    }\n  };\n}\n\nfunction respondToMessage(msg, process, error, response) {\n  msg.error = error;\n  msg.response = response;\n  cservice.processSafeSend(process, msg);\n}\n\nfunction processMessage(msg) {\n  var waiter = waiters[msg.waiterId];\n  if (!waiter) {\n    return false;\n  }\n\n  waiter.cb(msg.error, msg.response);\n\n  return true;\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/worker-ready.js":"var cservice = require(\"../cluster-service\"),\n  cluster = require(\"cluster\"),\n  util = require(\"util\"),\n  messageBus = require(\"./message-bus\"),\n  onWorkerStop = null;\n\nmodule.exports = exports = workerReady;\n\nfunction workerReady(options, forceIsWorker) {\n  if (cluster.isMaster === true && forceIsWorker !== true) {\n    return; // ignore if coming from master\n  }\n\n  if (cservice.locals.workerReady === true) {\n    return; // ignore dup calls\n  }\n\n  if (options === false) {\n    cservice.locals.workerReady = false;\n\n    return; // do not continue\n  }\n\n  cservice.locals.workerReady = true;\n\n  options = options || {};\n\n  if (options.servers) {\n    require(\"./net-servers\").add(options.servers);\n  }\n\n  onWorkerStop = options.onWorkerStop;\n\n  process.on(\"message\", onMessageFromMaster);\n\n  // allow worker to inform the master when ready to speed up initialization\n  cservice.processSafeSend(process,\n    messageBus.createMessage(\"workerReady\", {\n      onStop: (typeof options.onWorkerStop === \"function\")\n    })\n  );\n}\n\nfunction onMessageFromMaster(msg) {\n  if (!messageBus.isValidMessage(msg) ||\n    cservice.msgBus.processMessage(msg)) {\n    return;\n  }\n\n  switch (msg.cservice.cmd) {\n    case \"onWorkerStop\":\n      cservice.netServers.close(function() {\n        if (typeof onWorkerStop === \"function\") {\n          // if custom handler is provided rely on that to\n          // cleanup and exit process\n          onWorkerStop();\n        } else {\n          // otherwise we can exit now that net servers have exited gracefully\n          process.exit();\n        }\n      });\n      break;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/workers.js":"var cservice = require(\"../cluster-service\"),\n  cluster = require(\"cluster\");\n\nexports.get = get;\nexports.monitor = monitor;\nexports.getByPID = getByPID;\nexports.getByPIDFromCache = getByPIDFromCache;\nexports.exitGracefully = exitGracefully;\nexports.demote = demote;\n\nfunction get() {\n  var workers = [];\n  var cworkers = cluster.workers;\n  var k;\n  var worker;\n  for (k in cworkers) {\n    worker = cworkers[k];\n    if ((!worker.isDead || !worker.isDead())\n      && worker.suicide !== true\n      && worker.state !== \"none\") {\n      worker.pid = worker.process.pid;\n      workers.push(worker);\n    }\n  }\n\n  workers.send = send;\n\n  return workers;\n}\n\n// i hate O(N) lookups, but not hit hard enough to worry about optimizing at\n// this point. freshness is more important\nfunction getByPID(pid) {\n  var workers = get();\n  var i;\n  var worker;\n\n  for (i = 0; i < workers.length; i++) {\n    worker = workers[i];\n    if (worker.pid === pid) {\n      return worker;\n    }\n  }\n  // else return undefined\n}\n\nfunction getByPIDFromCache(pid) {\n  return cservice.locals.workers[pid];\n}\n\nfunction monitor() {\n  process.on(\"message\", function(msg) {\n    if (!cservice.msgBus.isValidMessage(msg)) {\n      return; // end\n    }\n\n    switch (msg.cservice.cmd) {\n      case \"processDetails\":\n        cservice.processSafeSend(process,\n          cservice.msgBus.createMessage(\"processDetails\", {\n            processDetails: {\n              memory: process.memoryUsage(),\n              title: process.title,\n              uptime: process.uptime(),\n              hrtime: process.hrtime()\n            }\n        }));\n        break;\n    }\n  });\n}\n\nfunction demote() {\n  // only demote if:\n  // 1. process.getgid is defined (not Windows)\n  // 2. Running as root\n  // 3. workerGid is string and not a proxy worker\n  var gid = cservice.options.workerGid || 'nobody';\n  var uid = cservice.options.workerUid || 'nobody';\n  if (process.getgid && process.getgid() === 0) {\n    if ( // but do not auto-demote proxy\n         // workers as they require priveledged port access\n      cluster.worker.env.type !== \"proxy\" &&\n      typeof cservice.options.workerGid === 'string'\n    ) {\n      process.setgid(gid);\n      process.setuid(uid);\n    } else {\n      cservice.log(\n        \"Worker running as root. Not advised for Production.\" +\n        \" Consider workerGid & workerUid options.\".warn\n      );\n    }\n\n  }\n\n}\n\n/**\n * This is shorthand for:\n * <pre>\n *  module.workers.forEach(function(worker){...});\n * </pre>\n */\nfunction send(){\n  this.forEach(function(worker){\n    worker.send.apply(worker, [].slice.apply(arguments));\n  });\n}\n\nfunction exitGracefully(worker) {\n  // inform the worker to exit gracefully\n  worker.send(cservice.msgBus.createMessage(\"onWorkerStop\"));\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/control.js":"var _controls = {};\nvar _keys = {};\n\nvar levels = {\n  \"remote\": 10, // anyone with credentials can access\n  \"local\": 20, // anyone locally with credentials can access\n  \"inproc\": 30, // CLI of the master process\n  \"disabled\": 99 // disabled\n};\n\nfunction setControls(controls) {\n  _controls = {};\n  return addControls(controls);\n}\n\nfunction addControls(controls) {\n  var control;\n  for (control in controls) {\n    if (levels[controls[control]] === undefined) {\n      throw(controls[control] + \" is not a valid control level.\");\n    }\n    _controls[control] = levels[controls[control]];\n  }\n  return _controls;\n}\n\nfunction setAccessKey(keys) {\n  _keys = {};\n  \n  var keyArr = keys.split(\";\");\n  for (var i = 0; i < keyArr.length; i++) {\n    var fullKey = keyArr[i];\n    var keyName = /([a-zA-Z0-9]*)?/.exec(fullKey)[0];\n    var keyDisabled = /[a-zA-Z0-9]*\\:disabled/.test(fullKey);\n    if (keyDisabled === true) {\n      _keys[keyName] = false;\n      continue;\n    }\n    \n    var key = { };\n    var cmdList = /\\[(.*)?\\]/.exec(fullKey);\n    if (cmdList && cmdList.length > 0) {\n      var cmds = cmdList[1].split(\",\");\n      for (var i2 = 0; i2 < cmds.length; i2++ ){\n        var fullCmd = cmds[i2];\n        var cmdName = /([a-zA-Z0-9]*)?/.exec(fullCmd)[0];\n        var cmdValStr = /\\:(.*)?/.exec(fullCmd);\n        var cmdVal = true;\n        if (cmdValStr && cmdValStr.length > 0) {\n          switch (cmdValStr[1]) {\n            case \"false\":\n            case \"disabled\":\n              cmdVal = \"disabled\";\n              break;\n            case \"remote\":\n              cmdVal = \"remote\";\n              break;\n            case \"local\":\n              cmdVal = \"local\";\n              break;\n            case \"inproc\":\n              cmdVal = \"inproc\";\n              break;\n          }\n          \n          key[cmdName] = cmdVal;\n        }\n      }\n    }\n\n    _keys[keyName] = key;\n  }\n}\n\nfunction authorize(name, currentControl, accessKey) {\n  if (typeof accessKey === \"string\" && accessKey in _keys) {\n    // if access key available, check rights\n    var rights = _keys[accessKey];\n    if (rights === false) {\n      return false; // DENIED\n    } else if (typeof rights === \"object\" && name in rights) {\n      // custom rights detected\n      var commandRight = rights[name];\n      if (typeof commandRight === \"boolean\") {\n        return commandRight; // return as is\n      } else if (typeof commandRight === \"string\" && commandRight in levels) {\n        return currentControl >= levels[commandRight];\n      }\n    }\n  }\n  \n  if (_controls[name]) {\n    return currentControl >= _controls[name];\n  }\n  // We default to \"remote\" which is full access\n  return currentControl >= levels.remote;\n}\n\nexports.setControls = setControls;\nexports.addControls = addControls;\nexports.setAccessKey = setAccessKey;\nexports.authorize = authorize;\nexports.levels = levels;","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/stop.js":"var cservice = require(\"../cluster-service\");\n\nmodule.exports = exports = stop;\n\nfunction stop(timeout, cb) {\n  if (cservice.locals.state === 0) {\n    if (cb) cb(null, \"Not running\");\n    return;\n  }\n\n  if (cservice.workers.length > 0) { // issue shutdown\n    cservice.trigger(\"shutdown\", function() {\n      handleWorkersExited(cb);\n    }, \"all\", timeout);\n  } else { // gracefully shutdown\n    handleWorkersExited(cb);\n  }\n}\n\nfunction handleWorkersExited(cb) {\n  if (cb) cb(null, \"Shutting down...\");\n  require(\"./http-server\").close();\n  cservice.locals.state = 0;\n  if (cservice.options.cli === true) {\n    process.exit(1);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/new-worker.js":"var cservice = require(\"../cluster-service\"),\n  cluster = require(\"cluster\"),\n  path = require(\"path\"),\n  fs = require(\"fs\"),\n  util = require(\"util\");\n\nmodule.exports = exports = newWorker;\n\nfunction newWorker(options, cb) {\n  var worker;\n  options = util._extend(util._extend({}, {\n    worker: \"./worker.js\",\n    count: undefined,\n    restart: true,\n    type: 'user',\n    version: undefined,\n    cwd: undefined,\n    onStop: false\n  }), options);\n  options.ready = false;\n  if (\n    options.worker.indexOf(\".\") === 0\n    || (options.worker.indexOf(\"//\") !== 0\n    && options.worker.indexOf(\":\\\\\") < 0)\n  ) {\n    // resolve if not absolute\n    options.worker = path.resolve(options.worker);\n  }\n  if (\n    fs.existsSync(options.worker) === false\n    && fs.existsSync(options.worker + \".js\") === false\n  ) {\n    if(cb){\n      cb(\n        \"Worker not found: '\"\n        + options.worker\n        + \"'. Set 'workers' option to proper path.\"\n      );\n    }\n    return null;\n  }\n  options.cwd = options.cwd || process.cwd();\n  options.onReady = cb;\n\n  var version;\n  if (options.version) {\n    // track workers with version\n    version = cservice.locals.proxy.versions[options.version];\n    if (!version) {\n      version = {\n        name: options.version,\n        port: options.PROXY_PORT,\n        lastAccess: Date.now(),\n        online: false\n      };\n      cservice.locals.proxy.versions[options.version] = version;\n    }\n  }\n\n  worker = cluster.fork(options);\n  worker.cservice = options;\n  worker.on(\"message\", onMessageFromWorker);\n\n  // track every worker by pid\n  cservice.locals.workerProcesses[worker.process.pid] = worker;\n\n  return worker;\n}\n\nfunction onMessageFromWorker(msg) {\n  var worker = this;\n  if (!cservice.msgBus.isValidMessage(msg)) {\n    return; // ignore invalid cluster-service messages\n  }\n\n  var args, version;\n\n  switch (msg.cservice.cmd) {\n    case \"workerReady\":\n      version = cservice.locals.proxy.versions[worker.cservice.version];\n      if (version) {\n        // if version detected within worker, flag as online\n        version.online = true;\n\n        // notify proxy workers of version update\n        cservice.proxy.updateProxyWorkers();\n      }\n      if (worker.cservice.ready === false) {\n        // preserve preference between restarts, etc\n        worker.cservice.ready = true;\n        worker.cservice.onStop = (msg.cservice.onStop === true);\n        if(typeof worker.cservice.onReady === \"function\"){\n          worker.cservice.onReady(null, worker);\n        }\n      }\n      break;\n    case \"trigger\":\n      args = msg.cservice.args;\n      if (args && args.length > 0) {\n        if (msg.cservice.cb === true) {\n          args.splice(1, 0, function(err, result) {\n            // forward response to worker that requested the trigger\n            cservice.msgBus.respondToMessage(msg, worker.process, err, result);\n          });\n        } else {\n          args.splice(1, 0, null); // no callback necessary\n        }\n        cservice.trigger.apply(cservice, args);\n      }\n      break;\n    case \"versionUpdateLastAccess\":\n      version = cservice.locals.proxy.versions[msg.cservice.version];\n      if (version) { // update freshness\n        version.lastAccess = Date.now();\n      }\n      break;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands.js":"var cservice = require(\"../cluster-service\"),\n    path = require(\"path\"),\n    fs = require(\"fs\"),\n    cluster = require(\"cluster\");\n\nexports.on = on;\nexports.register = register;\n\nfunction on(eventName, cb, overwriteExisting) {\n  var evt;\n  var controls;\n  if (cluster.isMaster === false) {\n    // no action to take on workers -- convenience feature as to not \n    // pollute master code\n    return;\n  }\n\n  overwriteExisting = overwriteExisting || true;\n  if (!overwriteExisting && eventName in cservice.locals.events) {\n    return; // do not overwrite existing\n  }\n\n  evt = {\n    name: eventName,\n    service: cservice,\n    locals: cservice.locals,\n    cb: cb\n  };\n\n  // Adding control for this eventName\n  if (typeof cb.control === \"function\") {\n    controls = {};\n    controls[eventName] = cb.control();\n    require(\"./control\").addControls(controls);\n  }\n\n  // overwrite existing, if any\n  cservice.locals.events[eventName] = evt;\n}\n\nfunction register(commands, overwriteExisting) {\n  if (typeof commands === \"string\") {\n    commands = commands.split(\",\");\n  } else if (typeof commands !== \"object\") {\n    throw new Error(\"Option 'commands' must be a comma-delimited \" +\n      \"string or an array of strings.\");\n  }\n\n  for (var i = 0; i < commands.length; i++) {\n    var dir = commands[i];\n    if (dir.indexOf(\":\\\\\") !== 1 && dir.indexOf(\"/\") !== 0) {\n      // if not absolute, resolve path from cwd\n      dir = path.resolve(process.cwd(), dir);\n    }\n\n    var files = fs.readdirSync(dir);\n    for (var f = 0; f < files.length; f++) {\n      var fn = path.resolve(dir, files[f]);\n      var ext = path.extname(fn);\n      if (ext !== \".js\")\n        continue; // only js files permitted\n      var basename = path.basename(fn, \".js\");\n      var mod = require(fn); // load command module\n      if (typeof mod.id === \"string\") {\n        basename = mod.id; // use module id if available\n      }\n      on(basename, mod, overwriteExisting);\n    }\n  }\n}\n\nif (cluster.isMaster === true && cservice.locals.firstTime === true) {\n\tcservice.locals.firstTime = false;\n\n  var dir = path.dirname(module.filename);\n  register(path.resolve(dir, \"./commands\"), false);\n}","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/exit.js":"var util = require(\"util\"),\n  cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb, cmd) {\n  if (cmd !== \"now\") {\n    cb(\"Invalid request, 'now' required. Try help exit\");\n    return;\n  }\n\n  cservice.log(\"*** FORCEFUL TERMINATION REQUESTED ***\".warn);\n  cservice.log(\"Exiting now.\".warn);\n  cb(null, \"Exiting now.\");\n  setTimeout(function() {\n    process.exit(0); // exit master\n  }, 100);\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    info: \"Forcefully exits the service.\",\n    command: \"exit now\",\n    \"now\": \"Required. 'now' to force exit.\"\n  });\n};\n\nmodule.exports.control = function() {\n  return \"local\";\n};\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/health.js":"var cluster = require(\"cluster\");\n\nmodule.exports = function(evt, cb) {\n  cb(null, \"OK\");\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    command: \"health\",\n    info: [\n      \"Returns health of service.\",\n      \"May be overidden by service to expose app-specific data.\"\n    ].join(' ')\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/help.js":"var util = require(\"util\");\n\nmodule.exports = function(evt, cb, cmdName) {\n  var evtName, cmd, ret = {};\n  if (typeof cmdName === \"string\") {\n    ret.command = cmdName;\n    cmd = evt.locals.events[cmdName];\n    if (!cmd) {\n      ret.err = \"Command not found\";\n    } else {\n      if (typeof cmd.cb.more === \"function\") {\n        cmd.cb.more(function(err, result) {\n          cb(null, result);\n        });\n        return;\n      } else {\n        ret.more = \"No additional details found.\";\n      }\n    }\n  } else { // full listing\n    ret.more = \"Commands (Use 'help [command_name]' for more details)\";\n    ret.commands = [];\n    for (evtName in evt.locals.events) {\n      cmd = evt.locals.events[evtName];\n      if (cmd.cb.visible === false)\n        continue;\n      ret.commands.push(evtName);\n    }\n  }\n\n  cb(null, ret);\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    \"command\": \"help [command_name]\",\n    \"command_name\": \"Optional if you want extended help\"\n  });\n};\n\nmodule.exports.control = function() {\n  return \"local\";\n};\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/info.js":"var cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb, cmd) {\n  cservice.trigger(\"workers\", function(err, results) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    var workers = results.workers;\n    var summary = {\n      workers: { active: workers.length },\n      memory: { rss: 0, heapTotal: 0, heapUsed: 0 },\n      net: {\n        connections: 0,\n        connectionsOpen: 0,\n        requests: 0,\n        avgRequests: 0,\n        avgConnections: 0\n      }\n    };\n    \n    for (var i = 0; i < workers.length; i++) {\n      var w = workers[i];\n      var p = w.process;\n      summary.memory.rss += p.memory.rss;\n      summary.memory.heapTotal += p.memory.heapTotal;\n      summary.memory.heapUsed += p.memory.heapUsed;\n      if (p.net) {\n        summary.net.connections += p.net.connections;\n        summary.net.connectionsOpen += p.net.connectionsOpen;\n        summary.net.requests += p.net.requests;\n        summary.net.avgRequests += p.net.avgRequests;\n        summary.net.avgConnections += p.net.avgConnections;\n      }\n    }\n    \n    cb(null, summary);\n  }, \"simple\");\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    command: \"info\",\n    info: \"Returns summary of process & workers.\"\n  });\n};\n\nmodule.exports.control = function() {\n  return \"remote\"; // consistent with \"workers\" command,\n                   // but may be locked down in the future\n};\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/locals.js":"var cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb) {\n  cb(null, cservice.locals);\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    command: \"locals\",\n    info: \"Returns locals state object for debug purposes.\"\n  });\n};\n\nmodule.exports.control = function() {\n  return \"local\";\n};\n\nmodule.exports.visible = false;\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/options.js":"var cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb) {\n  cb(null, cservice.locals);\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    command: \"options\",\n    info: \"Returns current options for debug purposes.\"\n  });\n};\n\nmodule.exports.control = function() {\n  return \"local\";\n};\n\nmodule.exports.visible = false;\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/proxy.js":"var cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb, cmd) {\n  var versionStr, options;\n  switch (cmd) {\n    case \"start\":\n      cservice.proxy.start({ configPath: arguments[3] }, cb);\n      break;\n    case \"stop\":\n      cservice.proxy.stop(cb);\n      break;\n    case \"version\":\n      versionStr = arguments[3];\n      options = {};\n      if (arguments[4]) {\n        options.workerCount = parseInt(arguments[4]);\n      }\n      cservice.proxy.version(versionStr, options, cb);\n      break;\n    case \"promote\":\n      versionStr = arguments[3];\n      options = {};\n      if (arguments[4]) {\n        options.workerCount = parseInt(arguments[4]);\n      }\n      cservice.proxy.promote(versionStr, options, cb);\n      break;\n    case \"info\":\n      cservice.proxy.info(cb);\n      break;\n    default:\n      cb(\"Proxy command \" + cmd +\n        \" not recognized. Try 'help proxy' for more info.\");\n      break;\n  }\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    command: \"proxy {cmd} {options}\",\n    info: \"Perform a proxy operation.\",\n    cmd: \"Available commands:\",\n    \"* start {configPath}\": \"Start proxy\",\n    \"* stop\": \"Stop proxy\",\n    \"* version {version} {workerCount}\":\n      \"Set a given version to desired worker count\",\n    \"* promote {version} [workerCount]\": \"Promote a worker version\",\n    \"* info\": \"Return proxy info, including a list of active versions\",\n    \"options\": \"Available options:\",\n    \"* configPath\": \"Path of proxy config file\",\n    \"* version\": \"Worker version (path)\",\n    \"* workerCount\": \"Desired number of workers\"\n  });\n};\n\nmodule.exports.control = function() {\n  return \"local\";\n};\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/restart.js":"var async = require(\"async\"),\n    util = require(\"util\"),\n    cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb, cmd, options) {\n  var pid = parseInt(cmd),\n      originalAutoRestart,\n      tasks;\n  options = options || {};\n  options.timeout = parseInt(options.timeout) || 60000;\n  if (cmd !== \"all\" && !pid) {\n    cb(\"Invalid request. Try help restart\");\n    return;\n  }\n\n  evt.locals.reason = \"restart\";\n  originalAutoRestart = evt.locals.restartOnFailure;\n  evt.locals.restartOnFailure = false;\n\n  tasks = [];\n\n  evt.service.workers.forEach(function(worker){\n    if (pid && worker.process.pid !== pid) {\n      return; // cannot kill external processes\n    }\n\n    tasks.push(getTask(evt, worker, options, (pid ? true : false)));\n  });\n\n  if (tasks.length === 0) {\n    cb(\"No workers to restart\");\n  } else {\n    cservice.log(\n      \"Restarting workers... timeout: \".warn + options.timeout.toString().info\n    );\n\n    var limit = 1 +\n        Math.floor(\n            tasks.length * cservice.options.restartConcurrencyRatio\n        );\n    async.parallelLimit(tasks, limit, function(err) {\n      evt.locals.restartOnFailure = originalAutoRestart; // restore\n\n      if (err) {\n        cb(err);\n      } else {\n        cb(null, tasks.length + \" workers restarted successfully\");\n      }\n    });\n  }\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    info: [\n      \"Gracefully restart service, waiting up to timeout before terminating\",\n      \"workers.\"\n    ].join(' '),\n    command: \"restart all|pid { \\\"option1\\\": \\\"value\\\" }\",\n    \"all|pid\": [\n      \"Required. 'all' to force shutdown of all workers, otherwise the pid of\",\n      \"the specific worker to restart\"\n    ].join(' '),\n    \"options\": \"An object of options.\",\n    \"* timeout\": [\n      \"Timeout, in milliseconds, before terminating workers.\",\n      \"0 for infinite wait.\"\n    ].join(' ')\n  });\n};\n\nfunction getTask(evt, worker, options, explicitRestart) {\n  return function(cb) {\n    var pendingWorker = null;\n\n    if (worker.cservice.restart === false && explicitRestart === false) {\n      cservice.log(\n        \"Worker process \" + worker.process.pid + \" immune to restarts\"\n      );\n      cb();\n      return;\n    }\n\n    // kill new worker if takes too long\n    var newWorkerTimeout = null;\n    var isNewWorkerTerminated = false;\n    if (options.timeout > 0) { // start timeout if specified\n      newWorkerTimeout = setTimeout(function() {\n        if (pendingWorker) {\n          isNewWorkerTerminated = true;\n          pendingWorker.on('exit', function () {\n            cb(\"timed out\");\n          });\n          pendingWorker.kill(\"SIGKILL\"); // go get'em, killer\n        }\n      }, options.timeout);\n    }\n\n    // lets start new worker\n    pendingWorker = evt.service.newWorker(worker.cservice, function(err) {\n      pendingWorker = null;\n      if (newWorkerTimeout) { // timeout no longer needed\n        clearTimeout(newWorkerTimeout);\n      }\n      if (isNewWorkerTerminated) return;\n\n      // ok, lets stop old worker\n      var oldWorkerTimeout = null;\n      if (options.timeout > 0) { // start timeout if specified\n        oldWorkerTimeout = setTimeout(function() {\n          worker.kill(\"SIGKILL\"); // go get'em, killer\n        }, options.timeout);\n      }\n\n      worker.on(\"exit\", function() {\n        if (oldWorkerTimeout) {\n          clearTimeout(oldWorkerTimeout);\n        }\n\n        // exit complete, fire callback\n        setImmediate(cb); // slight delay in case other events are piled up\n      });\n\n      require(\"../workers\").exitGracefully(worker);\n    });\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/shutdown.js":"/* jshint loopfunc:true */\n\nvar util = require(\"util\"),\n  cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb, cmd, options) {\n  var pid = parseInt(cmd);\n  var workersToKill;\n  var exiting;\n\n  options = options || {};\n  options.timeout = parseInt(options.timeout) || 60000;\n  if (cmd !== \"all\" && !pid) {\n    cb(\"Invalid request. Try help shutdown\");\n    return;\n  }\n\n  evt.locals.reason = \"shutdown\";\n\n  workersToKill = 0;\n\n  exiting = false;\n  evt.service.workers.forEach(function(worker){\n    if (pid && worker.process.pid !== pid) {\n      return; // cannot kill external processes\n    }\n\n    exiting = true;\n    workersToKill++;\n\n    var killTimeout = options.timeout > 0\n      ? setTimeout(getKiller(worker), options.timeout)\n      : null;\n    worker.on(\"exit\", getExitHandler(evt, worker, killTimeout, function() {\n      workersToKill--;\n      if (workersToKill === 0) {\n        // no workers remain\n        if (evt.service.workers.length === 0) {\n          evt.locals.reason = \"kill\";\n          cservice.log(\"All workers shutdown. Exiting...\".warn);\n          evt.service.stop(options.timeout, cb);\n        } else {\n          cb(null, \"Worker shutdown\"); // DONE\n        }\n      }\n    }));\n\n    require(\"../workers\").exitGracefully(worker);\n  });\n\n  if (exiting === false) {\n    if (evt.service.workers.length === 0) {\n      evt.locals.reason = \"kill\";\n      cservice.log(\"All workers shutdown. Exiting...\");\n      evt.service.stop(options.timeout, cb);\n    } else {\n      cb(\"No workers were shutdown\");\n    }\n  } else {\n    cservice.log(\n      \"Killing workers... timeout: \".warn +\n      (options.timeout || 0).toString().info\n    );\n  }\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    info: [\n      \"Gracefully shutdown service, waiting up to timeout before terminating\",\n      \"workers.\"\n    ].join(' '),\n    command: \"shutdown all|pid { \\\"option1\\\": \\\"value\\\" }\",\n    \"all|pid\": [\n      \"Required. 'all' to force shutdown of all workers, otherwise the pid of\",\n      \"the specific worker to shutdown\"\n    ].join(' '),\n    \"options\": \"An object of options.\",\n    \"* timeout\": [\n      \"Timeout, in milliseconds, before terminating workers. 0 for infinite\",\n      \"wait.\"\n    ].join(' ')\n  });\n};\n\nmodule.exports.control = function() {\n  return \"local\";\n};\n\nfunction getKiller(worker) {\n  return function() {\n    worker.kill(\"SIGKILL\"); // go get'em, killer\n  };\n}\n\nfunction getExitHandler(evt, worker, killer, cb) {\n  return function() {\n    if (killer) {\n      clearTimeout(killer);\n    }\n\n    cb();\n  };\n}","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/start.js":"var async = require(\"async\"),\n  util = require(\"util\"),\n  cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb, workerPath, options) {\n  var tasks;\n  var i;\n  \n  options = options || {};\n  options.cwd = options.cwd || process.cwd();\n  options.count = parseInt(options.count) || 1;\n  options.timeout = parseInt(options.timeout) || 60000;\n  options.worker = workerPath;\n  if (typeof workerPath !== \"string\" || options.count < 1) {\n    cb(\"Invalid request. Try help start\");\n    return;\n  }\n\n  evt.locals.reason = \"start\";\n  var originalAutoRestart = evt.locals.restartOnFailure;\n  evt.locals.restartOnFailure = false;\n\n  tasks = [];\n\n  cservice.log(\"Starting workers... timeout: \" + (options.timeout || 0));\n\n  for (i = 0; i < options.count; i++) {\n    tasks.push(getTask(evt, options));\n  }\n\n  async.series(tasks, function(err) {\n    evt.locals.restartOnFailure = originalAutoRestart; // restore\n\n    if (err) {\n      cb(err);\n    } else {\n      cb(null, tasks.length + \" workers started successfully\");\n    }\n  });\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    info: \"Gracefully start service, one worker at a time.\",\n    command: \"start workerPath { \\\"option1\\\": \\\"value\\\" }\",\n    \"workerPath\": [\n      \"Path of worker file (i.e. /workers/worker) to start, absolute path, or\",\n      \"relative to cwd.\"\n    ].join(' '),\n    \"options\": \"An object of options.\",\n    \"* cwd\": [\n      \"Path to set as the current working directory. If not provided, existing\",\n      \"cwd will be used.\"\n    ].join(' '),\n    \"* count\": \"The number of workers to start, or 1 if not specified.\",\n    \"* timeout\": [\n      \"Timeout, in milliseconds, before terminating replaced workers. 0 for\",\n      \"infinite wait.\"\n    ].join(' '),\n    \"* ready\":\n      \"If false, will wait for workerReady event before assuming success.\"\n  });\n};\n\nfunction getTask(evt, options) {\n  return function(cb) {\n    var pendingWorker;\n\n    // kill new worker if takes too long\n    var startTimeout = null;\n    var isWorkerTerminated = false;\n    if (options.timeout > 0) { // start timeout if specified\n      startTimeout = setTimeout(function() {\n        if (!pendingWorker)\n          return;\n        isWorkerTerminated = true;\n        pendingWorker.on('exit', function () {\n          cb(\"timed out\");\n        });\n        pendingWorker.kill(\"SIGKILL\"); // go get'em, killer\n      }, options.timeout);\n      startTimeout.unref();\n    }\n\n    // lets start new worker\n    pendingWorker = evt.service.newWorker(options, function(err) {\n      pendingWorker = null;\n\n      if (startTimeout) { // timeout no longer needed\n        clearTimeout(startTimeout);\n      }\n\n      if (!isWorkerTerminated) {\n        cb(err);\n      }\n    });\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/upgrade.js":"var async = require(\"async\"),\n  util = require(\"util\"),\n  cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb, cmd, workerPath, options) {\n  var pid = parseInt(cmd);\n  var originalAutoRestart;\n  var tasks;\n  var workerOptions;\n\n  options = options || {};\n  options.timeout = parseInt(options.timeout) || 60000;\n  options.worker = workerPath;\n  if (typeof workerPath !== \"string\" || (cmd !== \"all\" && !pid)) {\n    cb(\"Invalid request. Try help upgrade\");\n    return;\n  }\n\n  evt.locals.reason = \"upgrade\";\n  originalAutoRestart = evt.locals.restartOnFailure;\n  evt.locals.restartOnFailure = false;\n\n  tasks = [];\n\n  evt.service.workers.forEach(function(worker){\n    if (pid && worker.process.pid !== pid) {\n      return; // cannot kill external processes\n    }\n\n    // use original worker options as default, by overwrite using new options\n    workerOptions = util._extend(util._extend({}, worker.cservice), options);\n\n    tasks.push(getTask(evt, worker, workerOptions));\n  });\n\n  if (tasks.length === 0) {\n    cb(\"No workers to upgrade\");\n  } else {\n    cservice.log(\"Upgrading workers... timeout: \" + (options.timeout || 0));\n\n    var limit = 1 +\n        Math.floor(\n            tasks.length * cservice.options.restartConcurrencyRatio\n        );\n    async.parallelLimit(tasks, limit, function(err) {\n      evt.locals.restartOnFailure = originalAutoRestart;\n\n      if (err) {\n        cb(err);\n      } else {\n        cb(null, tasks.length + \" workers upgraded successfully\");\n      }\n    });\n  }\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    info: \"Gracefully upgrade service, one worker at a time.\",\n    command: \"upgrade all|pid workerPath { \\\"option1\\\": \\\"value\\\" }\",\n    \"all|pid\": [\n      \"Required. 'all' to force shutdown of all workers, otherwise the pid of\",\n      \"the specific worker to upgrade\"\n    ].join(' '),\n    \"workerPath\":[\n      \"Path of worker file (i.e. /workers/worker) to start, absolute path, or\",\n      \"relative to cwd.\"\n    ].join(' '),\n    \"options\": \"An object of options.\",\n    \"* cwd\":[\n      \"Path to set as the current working directory. If not provided, existing\",\n      \"cwd will be used.\"\n    ].join(' '),\n    \"* timeout\": [\n      \"Timeout, in milliseconds, before terminating replaced workers. 0 for\",\n      \"infinite wait.\"\n    ].join(' ')\n  });\n};\n\nfunction getTask(evt, worker, options) {\n  return function(cb) {\n\n    var pendingWorker;\n\n    // kill new worker if takes too long\n    var newWorkerTimeout = null;\n    var isNewWorkerTerminated = false;\n    if (options.timeout > 0) { // start timeout if specified\n      newWorkerTimeout = setTimeout(function() {\n        if (!pendingWorker) return;\n\n        isNewWorkerTerminated = true;\n        pendingWorker.on('exit', function () {\n          cb(\"timed out\");\n        });\n        pendingWorker.kill(\"SIGKILL\"); // go get'em, killer\n      }, options.timeout);\n    }\n\n    // lets start new worker\n    pendingWorker = evt.service.newWorker(options, function (err) {\n      pendingWorker = null;\n      if (newWorkerTimeout) { // timeout no longer needed\n        clearTimeout(newWorkerTimeout);\n      }\n\n      if (err) {\n        cb(err);\n        return;\n      }\n\n      // ok, lets stop old worker\n      var oldWorkerTimeout = null;\n      if (options.timeout > 0) { // start timeout if specified\n        oldWorkerTimeout = setTimeout(function() {\n          worker.kill(\"SIGKILL\"); // go get'em, killer\n        }, options.timeout);\n      }\n\n      worker.on(\"exit\", function() {\n        if (oldWorkerTimeout) {\n          clearTimeout(oldWorkerTimeout);\n        }\n\n        // exit complete, fire callback\n        setImmediate(cb); // slight delay in case other events are piled up\n      });\n\n      require(\"../workers\").exitGracefully(worker);\n    });\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/version.js":"var cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb) {\n  var pkg = require(\"../../package.json\");\n  cb(null, pkg.version);\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    info: \"Get version of cluster-service.\",\n    command: \"version\"\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/workerExit.js":"var path = require(\"path\"),\n  cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb, worker, reason) {\n\tcservice.log(\n    (\"Worker \"\n      + path.basename(worker.cservice.worker)\n      + \"(\"\n      + worker.process.pid\n      + \") exited, reason: \"\n      + (reason || worker.cservice.reason ||\n        cservice.locals.reason || \"Unknown\")).warn\n  );\n  cb();\n};\n\nmodule.exports.control = function() {\n  return \"inproc\";\n};\n\nmodule.exports.visible = false;\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/workerStart.js":"var path = require(\"path\"),\n  cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb, worker, reason) {\n\tcservice.log(\n    (\"Worker \"\n      + path.basename(worker.cservice.worker)\n      + \"(\"\n      + worker.process.pid\n      + \") start, reason: \"\n      + (reason || cservice.locals.reason || \"Unknown\")).success\n  );\n  cb();\n};\n\nmodule.exports.control = function() {\n  return \"inproc\";\n};\n\nmodule.exports.visible = false;\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/commands/workers.js":"var async = require(\"async\");\nvar cservice = require(\"../../cluster-service\");\n\nmodule.exports = function(evt, cb, cmd) {\n  processDetails(evt.service.workers, function(err, workers) {\n    var ret = {};\n    cmd = cmd || \"simple\";\n    switch (cmd) {\n      case \"details\":\n        ret.workers = workers;\n        break;\n      default:\n        ret.workers = workerSummary(workers);\n        break;\n    }\n\n    cb(err, ret);\n  });\n};\n\nmodule.exports.more = function(cb) {\n  cb(null, {\n    command: \"workers [simple|details]\",\n    info: \"Returns list of active worker processes.\",\n    \"simple|details\": \"Defaults to 'simple'.\",\n    \"* simple\": \"Simple overview of running workers.\",\n    \"* details\": \"Full details of running workers.\"\n  });\n};\n\nfunction processDetails(workers, cb) {\n  var tasks = [], i, w;\n\n  for (i = 0; i < workers.length; i++) {\n    w = workers[i];\n    tasks.push(getProcessDetails(w));\n  }\n  async.parallel(tasks, function(err, results) {\n    cb(err, workers);\n  });\n}\n\nfunction getProcessDetails(worker) {\n  return function(cb) {\n    var timer, msgCb, processDetails, netStats;\n    msgCb = function (msg) {\n      if (msg && msg.cservice.processDetails) {\n        processDetails = msg.cservice.processDetails;\n      }\n      if (msg && msg.cservice.netStats) {\n        netStats = msg.cservice.netStats;\n      }\n      if (processDetails && netStats) {\n        clearTimeout(timer);\n        worker.removeListener(\"message\", msgCb);\n        worker.processDetails = processDetails;\n        processDetails.net = netStats;\n        cb(null, worker);\n      }\n    };\n    timer = setTimeout(function() {\n      worker.removeListener(\"message\", msgCb);\n      if (processDetails) { // net stats not required for success\n        worker.processDetails = processDetails;\n        cb(null, worker);\n      } else {\n        cb(\"getProcessDetails TIMEOUT\");\n      }\n    }, 1000);\n\n    worker.on(\"message\", msgCb);\n    cservice.processSafeSend(worker.process,\n        cservice.msgBus.createMessage(\"processDetails\")\n    );\n    cservice.processSafeSend(worker.process,\n        cservice.msgBus.createMessage(\"netStats\")\n    );\n  };\n}\n\nfunction workerSummary(workers) {\n  var ret = [], i, w;\n\n  for (i = 0; i < workers.length; i++) {\n    w = workers[i];\n    ret.push({\n      id: w.id,\n      pid: w.pid,\n      state: w.state,\n      worker: w.cservice.worker,\n      cwd: w.cservice.cwd,\n      process: w.processDetails\n    });\n  }\n\n  return ret;\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/trigger.js":"var cservice = require(\"../cluster-service\");\n\nmodule.exports = exports = trigger;\n\nfunction trigger(eventName, cb) {\n  var args = Array.prototype.slice.call(arguments);\n  if (cservice.isWorker === true) {\n    args.splice(1, 1); // remove cb from args if it exists\n    cservice.msgBus.sendMessage(\"trigger\", { args: args, cb: true },\n      null, function(err, result) {\n      // wait for response from master\n      if (typeof cb === \"function\") {\n        cb(err, result);\n      }\n    });\n    return;\n  }\n  var evt = cservice.locals.events[eventName];\n  var i;\n  if (!evt) {\n    // invoke callback if provided instead of throwing\n    if (typeof cb === \"function\") {\n      cb(\"Event \" + eventName + \" not found\");\n    } else {\n      throw new Error(\"Event \" + eventName + \" not found\");\n    }\n  }\n\n  args.splice(0, 1, evt);\n\n  if (typeof cb !== \"function\") {\n    // auto-inject dummy callback if not provided\n    args.splice(1, 0, function DummyCallback(err, results) {\n      // do nothing\n    });\n  }\n\n  // invoke event callback\n  return evt.cb.apply(null, args);\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/start.js":"var cservice = require(\"../cluster-service\"),\n  cluster = require(\"cluster\"),\n  fs = require(\"fs\"),\n  path = require(\"path\"),\n  colors = require(\"colors\"),\n  util = require(\"util\");\n\nmodule.exports = exports = start;\n\nstart.prepArgs = prepArgs;\n\nfunction start(options, masterCb) {\n  var argv;\n  if (cluster.isWorker === true) {\n    // ignore starts if not master. do NOT invoke masterCb, as that is\n    // reserved for master callback\n\n    return;\n  }\n\n  if (arguments.length === 0) {\n    argv = require(\"optimist\").argv;\n\n    options = argv; // use command-line arguments instead\n    if (!(\"cli\" in options)) {\n      options.cli = true; // auto-enable cli if run from command-line\n    }\n    prepArgs(options);\n    masterCb = masterCallback;\n  }\n\n  options = options || {};\n  if (\"config\" in options) {\n    // only extend with config, do not overwrite command-line options\n    var fileOptions = JSON.parse(fs.readFileSync(options.config));\n    options = util._extend(fileOptions, options);\n  }\n  cservice.locals.options = util._extend(cservice.locals.options, options);\n  if (\"workers\" in options) { // overwrite workers if provided\n    cservice.locals.options.workers = options.workers;\n  }\n  options = cservice.locals.options;\n  if (typeof options.workers === \"string\") {\n    options.workers = {\n      main: {\n        worker: options.workers\n      }\n    };\n  }\n  if (options.commands) {\n    cservice.registerCommands(options.commands);\n  }\n\n  colors.setTheme(options.colors);\n\n  require(\"./legacy\");\n\n  if (options.run) {\n    require(\"./run\").start(options, function(err, result) {\n      if (masterCb && masterCb(err, result) === false) {\n        return; // do not exit if cb returns false\n      }\n      process.exit(0); // graceful exit\n    });\n  } else {\n    require(\"./master\").start(options, masterCb);\n  }\n}\n\nfunction masterCallback(err) {\n  if (err) {\n    cservice.error(err);\n    cservice.log(\"Startup failed, exiting...\".warn);\n    process.exit(0); // graceful exit\n  }\n}\n\nfunction prepArgs(options) {\n  var ext;\n  if (options._ && options._.length > 0) {\n    ext = path.extname(options._[0]).toLowerCase();\n    if (ext === \".js\") { // if js file, use as worker\n      options.workers = options._[0];\n    } else if (ext === \".json\") { // if json file, use as config\n      options.config = options._[0];\n    } else { // otherwise assume it is a command to execute\n      options.run = options._[0];\n      if (options.json === true) {\n        options.cli = false;\n      }\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/net-servers.js":"var cservice = require(\"../cluster-service\");\nvar util = require(\"util\");\nvar net = require(\"net\");\nvar netStats = require(\"./net-stats\");\nvar async = require(\"async\");\n\nvar netServers = {\n  add: netServersAdd,\n  remove: netServersRemove,\n  waitForReady: netServersWaitForReady,\n  close: netServersClose\n};\n\nmodule.exports = exports = netServers;\n\nwireupNetServerProto(); // init\n\nfunction netServersAdd(servers) {\n  if (util.isArray(servers) === false) {\n    servers = [servers];\n  }\n\n  for (var i = 0; i < servers.length; i++) {\n    var server = servers[i];\n    if (server.cservice)\n      continue; // ignore if already added\n\n    server.cservice = {\n      id: Math.random().toString(), // track by id\n      isReady: true // assume true unless known to be otherwise\n    };\n    cservice.locals.net.servers[server.cservice.id] = server;\n\n    listenToNetServer(server);\n    netStats(server);\n  }\n}\n\nfunction netServersRemove(servers) {\n  if (util.isArray(servers) === false) {\n    servers = [servers];\n  }\n\n  for (var i = 0; i < servers.length; i++) {\n    var server = servers[i];\n    if (!server.cservice)\n      continue; // ignore if not tracked by cservice\n    // stop tracking\n    delete cservice.locals.net.servers[server.cservice.id];\n    // unreference from cservice\n    delete server.cservice;\n\n    stopListeningToNetServer(server);\n  }\n}\n\nfunction netServersWaitForReady(cb) {\n  var tasks = [];\n\n  for (var id in cservice.locals.net.servers) {\n    var server = cservice.locals.net.servers[id];\n    if (!server.cservice || server.cservice.isReady === true)\n      continue;\n\n    tasks.push(createWaitForReadyTask(server));\n  }\n\n  if (tasks.length === 0) {\n    return cb();\n  }\n\n  async.parallel(tasks, cb);\n}\n\nfunction createWaitForReadyTask(server) {\n  return function(cb) {\n    var ticks = 0;\n    var timer = setInterval(function() {\n      if (!server.cservice // unregistered\n        || server.cservice.isReady === true // now ready\n        || ticks++ > 1000 // timeout (~10sec)\n      ) {\n        clearInterval(timer);\n        cb(null, true);\n      }\n    }, 10); // aggressive polling loop since it is uncommon task but a priority\n    timer.unref();\n  };\n}\n\nfunction netServersClose(cb) {\n  var tasks = [];\n\n  for (var id in cservice.locals.net.servers) {\n    var server = cservice.locals.net.servers[id];\n    if (!server.cservice || server.cservice.isReady === false)\n      continue;\n\n    tasks.push(createWaitForCloseTask(server));\n  }\n\n  if (tasks.length === 0) {\n    return cb();\n  }\n\n  async.parallel(tasks, cb);\n}\n\nfunction createWaitForCloseTask(server) {\n  return function(cb) {\n    server.once(\"close\", function() { cb(null, true); });\n    server.close();\n  };\n}\n\nvar serverListenOld;\n\nfunction wireupNetServerProto() {\n  serverListenOld = net.Server.prototype.listen;\n\n  net.Server.prototype.listen = serverListenNew;\n}\n\nfunction listenToNetServer(server) {\n  server.on(\"close\", serverOnClose);\n}\n\nfunction stopListeningToNetServer(server) {\n  server.removeListener(\"listening\", serverOnListening);\n  server.removeListener(\"close\", serverOnClose);\n}\n\nfunction serverListenNew() {\n  netServersAdd(this); // track net server\n\n  this.cservice.isReady = false; // not ready\n  this.on(\"listening\", serverOnListening); // ready on event\n\n  return serverListenOld.apply(this, arguments); // call original listen\n}\n\nfunction serverOnListening() {\n  if (!this.cservice)\n    return; // ignore\n\n  this.cservice.isReady = true;\n}\n\nfunction serverOnClose() {\n  if (!this.cservice)\n    return; // ignore\n\n  this.cservice.isReady = false;\n\n  // stop monitoring closed connections\n  netServersRemove(this);\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/net-stats.js":"var cservice = require(\"../cluster-service\");\n\nmodule.exports = exports = netStats;\n\nvar monitoring = false, statTimer;\nvar net = {\n  requests: 0,\n  connections: 0,\n  connectionsOpen: 0,\n  avgRequests: 0,\n  avgConnections: 0\n};\nvar stats = {\n  lastCheck: new Date().getTime(),\n  connections: 0,\n  requests: 0\n};\n\nfunction netStats(server) {\n  if (monitoring === false) {\n    monitoring = true;\n    monitor(); // init monitor\n  }\n\n  server.on(\"connection\", function(connection) {\n    net.connections++;\n    net.connectionsOpen++;\n    connection.on(\"close\", function() {\n      net.connectionsOpen--;\n    });\n  });\n\n  server.on(\"request\", function() {\n    net.requests++;\n  });\n}\n\nvar STAT_FREQUENCY = 1000;\nvar STAT_FACTOR = 3;\n\n// Why in its own monitor? Worker may reference different version of cservice\n// than the master, which is where these stats are tracked (to avoid blasting\n// messages when the data is not needed).\n// TODO: Move worker stats to its own class so this technique can be leveraged\n//       for any type of stats in the future.\nfunction monitor() {\n  statTimer = setInterval(statTracker, STAT_FREQUENCY);\n  statTimer.unref();\n\n  process.on(\"message\", function(msg) {\n    if (!cservice.msgBus.isValidMessage(msg)) {\n      return; // ignore\n    }\n\n    switch (msg.cservice.cmd) {\n      case \"netStats\":\n        cservice.processSafeSend(process,\n          cservice.msgBus.createMessage(\"netStats\", {\n            netStats: net\n        }));\n        break;\n    }\n  });\n}\n\nfunction statTracker() {\n  var now = new Date().getTime();\n  var timeDiff = now - stats.lastCheck;\n  var reqDiff = net.requests - stats.requests;\n  var conDiff = net.connections - stats.connections;\n  var reqPsec = (reqDiff / timeDiff) * 1000;\n  var conPsec = (conDiff / timeDiff) * 1000;\n\n  net.avgRequests = (reqPsec + (net.avgRequests * (STAT_FACTOR - 1)))\n    / STAT_FACTOR\n  ;\n  net.avgConnections = (conPsec + (net.avgConnections * (STAT_FACTOR - 1)))\n    / STAT_FACTOR\n  ;\n\n  // reset\n  stats.lastCheck = now;\n  stats.requests = net.requests;\n  stats.connections = net.connections;\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/proxy.js":"var cservice = require(\"../cluster-service\");\nvar cluster = require(\"cluster\");\nvar workersHelper = require(\"./workers\");\nvar path = require(\"path\");\nvar async = require(\"async\");\nvar fs = require(\"fs\");\n\nmodule.exports = {\n  start: start,\n  stop: stop,\n  version: version,\n  promote: promote,\n  updateProxyWorkers: updateProxyWorkers,\n  getProxyWorkers: getProxyWorkers,\n  getVersionWorkers: getVersionWorkers,\n  info: info\n};\n\nfunction start(options, cb) {\n  if (cluster.isWorker === true) {\n    cservice.log(\"Proxy cannot be started from worker\".warn);\n    return cb && cb(\"Proxy cannot be started from worker\");\n  }\n\n  var configPath = options.configPath || cservice.options.proxy;\n\n  if (typeof configPath !== \"string\") {\n    // disabled\n    return cb && cb();\n  }\n\n  if (cservice.locals.proxy.enabled === true) {\n    cservice.log(\"Proxy already running\".warn);\n    return cb && cb(\"Proxy already running\");\n  }\n\n  cservice.locals.proxy.configPath = path.resolve(configPath);\n  cservice.locals.proxy.options =\n    JSON.parse(fs.readFileSync(cservice.locals.proxy.configPath))\n  ;\n\n  options = cservice.locals.proxy.options;\n\n  if (Array.isArray(options.bindings) === false ||\n    options.bindings.length === 0) {\n    options.bindings = [{ port: 80, workerCount: 2 }]; // default\n  }\n\n  options.nonDefaultWorkerCount = options.nonDefaultWorkerCount || 1;\n  options.nonDefaultWorkerIdleTime = options.nonDefaultWorkerIdleTime || 3600;\n\n  cservice.locals.proxy.versionPath =\n    options.versionPath || path.dirname(cservice.locals.proxy.configPath)\n  ;\n  cservice.locals.proxy.versionPath =\n    path.resolve(cservice.locals.proxy.versionPath)\n  ;\n  cservice.locals.proxy.workerFilename = options.workerFilename || \"worker.js\";\n  cservice.locals.proxy.versionHeader = options.versionHeader || \"x-version\";\n\n  var portRange = (options.versionPorts || \"11000-12000\").split(\"-\");\n  cservice.locals.proxy.portRange = {\n    min: parseInt(portRange[0]),\n    max: parseInt(portRange[1])\n  };\n  cservice.locals.proxy.nextAvailablePortIndex = 0;\n\n  var proxyWorkerTasks = options.bindings.map(function(b) {\n    return function(cb) {\n      var workerOptions = {\n        type: \"proxy\", // proxy worker type\n        worker: path.resolve(__dirname, \"proxy-worker.js\"),\n        bindingInfo: JSON.stringify(b),\n        versionPath: cservice.locals.proxy.versionPath,\n        versionHeader: cservice.locals.proxy.versionHeader,\n        workerFilename: cservice.locals.proxy.workerFilename,\n        versions: JSON.stringify(cservice.locals.proxy.versions),\n        count: b.workerCount || 2\n      };\n      cservice.newWorker(workerOptions, cb);\n    };\n  });\n\n  cservice.locals.proxy.refreshnessTimer =\n    setInterval(checkVersionsForFreshness, 10000)\n  ;\n  cservice.locals.proxy.refreshnessTimer.unref();\n\n  cservice.locals.proxy.enabled = true;\n\n  async.parallel(proxyWorkerTasks, function (err) {\n    var portArr = options.bindings.map(function(b) {\n      return b.port.toString().data;\n    });\n\n    if (err) {\n      cservice.error(\"Proxy failed to run on ports \".error +\n        portArr.join(\",\".info) + \" with error \".error + err.toString().data);\n      return cb && cb(err);\n    }\n\n    cservice.log(\"Proxy running on ports \".info + portArr.join(\",\".info));\n\n    if (!cservice.locals.proxy.options.defaultVersion) {\n      // no current version\n\n      return cb && cb();\n    }\n\n    version(cservice.locals.proxy.options.defaultVersion,\n      { workerCount: cservice.locals.options.workerCount },\n      function (err, version) {\n      if (err) {\n        cservice.error(\"Proxy failed to run on ports \".error +\n          portArr.join(\",\".info) + \" with error \".error + err.toString().data\n        );\n        return cb && cb(err);\n      }\n\n      return cb && cb();\n    });\n  });\n}\n\nfunction stop(cb) {\n  if (cluster.isWorker === true) {\n    cservice.log(\"Proxy cannot be stopped from worker\".warn);\n    return cb && cb(\"Proxy cannot be stopped from worker\");\n  }\n\n  if (typeof cservice.locals.proxy.configPath !== \"string\") {\n    // disabled\n    return cb && cb();\n  }\n\n  if (cservice.locals.proxy.enabled === false) {\n    cservice.log(\"Proxy not running\".warn);\n    return cb && cb(\"Proxy not running\");\n  }\n\n  clearInterval(cservice.locals.proxy.refreshnessTimer);\n  cservice.locals.proxy.refreshnessTimer = null;\n\n  // now lets trigger a shutdown\n  cservice.trigger(\"shutdown\", function(err, result) {\n    cservice.locals.proxy.enabled = false;\n    return cb && cb();\n  }, \"all\");\n}\n\nfunction version(versionStr, options, cb) {\n  if (cluster.isWorker === true) {\n    cservice.log(\"Proxy cannot invoke 'version' from worker\".warn);\n    return cb && cb(\"Proxy cannot invoke 'version' from worker\");\n  }\n\n  options = options || {};\n  if (isNaN(options.workerCount) === true) {\n    options.workerCount =\n      (versionStr === cservice.locals.proxy.options.defaultVersion)\n      ? cservice.locals.options.workerCount\n      : cservice.locals.proxy.options.nonDefaultWorkerCount\n    ;\n  }\n\n  // detect current version worker count\n  var currentVersionWorkers = getVersionWorkers(versionStr);\n\n  // determine worker delta from desired count and actual count\n  var workerCountDelta = options.workerCount - currentVersionWorkers.length;\n\n  // get existing version listing\n  var v = cservice.locals.proxy.versions[versionStr];\n\n  if (v) {\n    // update version lastAccess\n    v.lastAccess = Date.now();\n  }\n\n  // if version worker count is already current, nothing more to do\n  if (workerCountDelta === 0) {\n    return cb && cb();\n  }\n\n  if (workerCountDelta < 0) {\n    // if desired version count is less than current, reduce worker count\n    var workersToShutdown = currentVersionWorkers.length - options.workerCount;\n    var shutdownTasks = [];\n    for (var workerToShutdown = 0; workerToShutdown < workersToShutdown;\n      workerToShutdown++) {\n      shutdownTasks.push(\n        getWorkerShutdownTask(\n          currentVersionWorkers[workerToShutdown],\n          options.reason || \"proxy version\"\n        )\n      );\n    }\n\n    // shutdown all at once\n    async.parallel(shutdownTasks, function (err, results) {\n      return cb && cb(err);\n    });\n\n    return;\n  }\n\n  // if desired version count is more than current, spin up new workers\n\n  var workerPath = path.resolve(cservice.locals.proxy.versionPath,\n    versionStr, cservice.locals.proxy.workerFilename\n  );\n\n  // use existing port if available, otherwise allocate a new one\n  var versionPort = (v && v.port) || getNextAvailablePort();\n\n  cservice.trigger(\"start\", function (err, result) {\n    return cb && cb(err, result);\n  }, workerPath, {\n    count: workerCountDelta,\n    version: versionStr,\n    PROXY_PORT: versionPort\n  });\n}\n\nfunction getWorkerShutdownTask(worker, reason) {\n  return function(cb) {\n    worker.cservice.reason = reason;\n    cservice.trigger(\"shutdown\", cb, worker.process.pid);\n  };\n}\n\nfunction getNextAvailablePort() {\n  // always continue where we left off from the last time\n  // we fetched an available port.\n  // this generally will allow us to return in O(1),\n  // unless there are tons of active versions.\n  var totalPorts = cservice.locals.proxy.portRange.max\n    - cservice.locals.proxy.portRange.min\n  ;\n  for (var i = 0; i < totalPorts; i++) {\n    var port = cservice.locals.proxy.portRange.min\n      + ((cservice.locals.proxy.nextAvailablePortIndex + i) % totalPorts);\n    if (isPortInUse(port) === false) {\n      cservice.locals.proxy.nextAvailablePortIndex = ((i + 1) % totalPorts);\n      return port;\n    }\n  }\n\n  throw new Error(\n    \"All proxy ports have been used up! Try increasing range of \" +\n    \"`proxy.versionPorts` or reducing `proxy.nonDefaultWorkerIdleTime`.\");\n}\n\nfunction isPortInUse(port) {\n  for (var k in cservice.locals.proxy.versions) {\n    if (cservice.locals.proxy.versions.hasOwnProperty(k) === false) {\n      continue; // ignore\n    }\n    if (cservice.locals.proxy.versions[k].port === port) {\n      return true; // NOT available\n    }\n  }\n\n  // if we get this far, we're OK to use port\n  return false;\n}\n\nfunction promote(versionStr, options, cb) {\n  if (cluster.isWorker === true) {\n    cservice.log(\"Proxy cannot invoke 'promote' from worker\".warn);\n    return cb && cb(\"Proxy cannot invoke 'promote' from worker\");\n  }\n\n  options = options || {};\n  options.workerCount = options.workerCount ||\n    cservice.locals.options.workerCount\n  ;\n\n  var oldVersion = cservice.locals.proxy.versions[\n    cservice.locals.proxy.options.defaultVersion\n  ];\n\n  // set to-be-promoted version to desired worker count\n  version(versionStr, options, function (err) {\n    if (err) {\n      // pass failure on\n      return cb && cb(err);\n    }\n\n    // persist to-be-promoted version\n    cservice.locals.proxy.options.defaultVersion = versionStr;\n    fs.writeFile(cservice.locals.proxy.configPath,\n      JSON.stringify(cservice.locals.proxy.options, null, \"  \"), function(err) {\n      if (err) {\n        // pass failure on\n        cservice.error(\"Failed to proxy promote version\".error +\n          versionStr.info\n        );\n        return cb && cb(err);\n      }\n\n      // notify proxy-workers of promoted version\n      updateProxyWorkers();\n\n      cservice.log(\"Proxy promoted version \".success +\n        versionStr.info +\n        \" successfully\".success\n      );\n\n      // bring previously promoted version down to\n      // `nonDefaultWorkerCount` workers, but no need to wait for callback\n      if (oldVersion && oldVersion.name !== versionStr) {\n        version(oldVersion.name,\n          {\n            workerCount: cservice.locals.proxy.options.nonDefaultWorkerCount,\n            reason: \"proxy demote\"\n          }, function(err) {\n            if (err) {\n              return cservice.error(\"Failed to proxy demote version\".error +\n                oldVersion.name.info\n              );\n            }\n\n            cservice.log(\"Proxy demoted old version \".success +\n              oldVersion.name.info +\n              \" successfully\".success\n            );\n          }\n        );\n      }\n\n      if (cb) {\n        setImmediate(cb);\n      }\n    });\n  });\n}\n\nfunction updateProxyWorkers() {\n  var msg = cservice.msgBus.createMessage(\"proxyVersions\", {\n    versions: cservice.locals.proxy.versions,\n    defaultVersion: cservice.locals.proxy.options.defaultVersion\n  });\n  getProxyWorkers().forEach(function(worker) {\n    worker.send(msg);\n  });\n}\n\nfunction info(cb) {\n  if (cluster.isWorker === true) {\n    cservice.log(\"Proxy cannot invoke 'info' from worker\".warn);\n    return cb && cb(\"Proxy cannot invoke 'info' from worker\");\n  }\n\n  var now = Date.now();\n  var proxyWorkers = getProxyWorkers().map(function(worker) {\n    var bindingInfo = JSON.parse(worker.cservice.bindingInfo);\n    return {\n      port: bindingInfo.port,\n      ssl: typeof bindingInfo.tlsOptions === \"object\"\n    };\n  });\n  var versionWorkers = getVersionWorkers().map(function(worker) {\n    var versionInfo = cservice.locals.proxy.versions[worker.cservice.version];\n    return {\n      worker: worker.cservice.worker,\n      version: worker.cservice.version,\n      lastAccess: versionInfo ?\n        Math.round((now - versionInfo.lastAccess) / 1000) : \"?\"\n    };\n  });\n\n  cb(null, {\n    versionPath: cservice.locals.proxy.versionPath,\n    workerFilename: cservice.locals.proxy.workerFilename,\n    portRange: cservice.locals.proxy.portRange,\n    options: cservice.locals.proxy.options,\n    proxyWorkers: proxyWorkers,\n    versionWorkers: versionWorkers\n  });\n\n}\n\nfunction getProxyWorkers() {\n  return cservice.workers.filter(function(worker) {\n    return worker.cservice.type === \"proxy\";\n  });\n}\n\nfunction getVersionWorkers(explicitVersion) {\n  return cservice.workers.filter(function(worker) {\n    var result =\n      typeof worker.cservice.version === \"string\" &&\n      (!explicitVersion || worker.cservice.version === explicitVersion)\n    ;\n    return result;\n  });\n}\n\nfunction isVersionRunning(versionStr, cb) {\n  if (!(versionStr in cservice.locals.proxy.versions)) {\n    return false; // version not available\n  }\n\n  // are any worker processes running desired version?\n  var workers = cservice.locals.workerProcesses;\n\n  for (var i = 0; i < workers.length; i++) {\n    var worker = workers[i];\n    var pid = worker.process.pid;\n  }\n\n  return false; // no workers running desired version\n}\n\nfunction checkVersionsForFreshness() {\n  var now = Date.now();\n  for (var k in cservice.locals.proxy.versions) {\n    if (\n      // live version is exempt\n      k === cservice.locals.proxy.options.defaultVersion ||\n      // verify a valid version\n      !cservice.locals.proxy.versions.hasOwnProperty(k)) {\n      continue; // skip\n    }\n    var v = cservice.locals.proxy.versions[k];\n    var diff = (now - v.lastAccess) / 1000; // seconds\n    if (diff < cservice.locals.proxy.options.nonDefaultWorkerIdleTime) {\n      continue; // all OK\n    }\n\n    cservice.log(\"Proxy version \".warn + k.info +\n      \" shutting down due to inactivity\".warn\n    );\n\n    // kill all the things\n    version(k, { workerCount: 0 });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/http-client.js":"var util = require(\"util\"),\n  http = require(\"http\"),\n  querystring = require(\"querystring\"),\n  options = null,\n  cservice = require(\"../cluster-service\");\n\nexports.init = function(o) {\n  options = o;\n\n  cservice.log([\n      \"Service already running. Attached CLI to master service.\",\n      \"Enter 'help [enter]' for help.\"\n    ]\n    .join(' ')\n    .info\n  );\n\n  if (!options || options.silentMode !== true) {\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on(\"data\", onCommand);\n    process.stdout.write(\"cservice> \".cservice);\n  }\n};\n\nexports.execute = onCommand;\n\nfunction onCommand(question, cb) {\n  var split, qs, url, body, err;\n  question = question.replace(/[\\r\\n]/g, \"\");\n  split = question.split(\" \");\n  if (split[0] === \"exit\") {\n    cservice.log(\"Exiting CLI ONLY.\".yellow);\n    process.kill(process.pid, \"SIGKILL\"); // exit by force\n    return;\n  }\n  qs = querystring.stringify({\n    cmd: question,\n    accessKey: options.accessKey\n  });\n  url = \"http://\"\n    + (options.host || \"localhost\")\n    + \":\"\n    + (options.port || 11987)\n    + \"/cli\"\n    + \"?\"\n    + qs;\n  cservice.log(\n    \"Running remote command: \".warn\n    + url.replace(/accessKey=.*/i, \"accessKey={ACCESS_KEY}\").data\n  );\n  body = \"\";\n  http.request(\n    {\n      host: options.host || \"localhost\",\n      port: options.port || 11987,\n      path: \"/cli?\" + qs,\n      method: \"POST\"\n    }\n    , function(res) {\n      res.setEncoding('utf8');\n      res.on(\"data\", function(chunk) {\n        body += chunk;\n      });\n      res.on(\"end\", function() {\n        if (res.statusCode !== 200 && body) {\n          err = body;\n        }\n        onCallback(err, body, res, cb);\n      });\n    }\n  ).on(\"error\", function(err) {\n      body = err;\n      onCallback(err, body, null, cb);\n    }\n  ).end();\n}\n\nfunction onCallback(err, result, res, cb) {\n  if (err) {\n    cservice.error(\"Error: \", err);\n    result = {statusCode: res ? res.statusCode : \"unknown\", error: err};\n  } else if (result) {\n    if (\n      typeof result === \"string\"\n      && (result.indexOf(\"{\") === 0 || result.indexOf(\"[\") === 0)\n    ) {\n      result = JSON.parse(result); // deserialize\n    }\n  }\n  cservice.log(util.inspect(result, {depth: null, colors: true}));\n\n  if (!options || options.silentMode !== true) {\n    //cservice.log(\"\");//newline\n    process.stdout.write(\"cservice> \".cservice);\n  }\n\n  if(cb){\n    cb(err, result);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/http-server.js":"var cservice = require(\"../cluster-service\"),\n  util = require(\"util\"),\n  http = require(\"http\"),\n  https = require(\"https\"),\n  querystring = require(\"querystring\"),\n  control = require(\"./control\"),\n  options = null,\n  server = null;\n\nexports.init = function(o, cb) {\n  options = o;\n\n  if (options.ssl) { // HTTPS\n    server = cservice.locals.http =\n      https.createServer(options.ssl, processRequest)\n    ;\n  } else { // HTTP\n    server = cservice.locals.http =\n      http.createServer(processRequest)\n    ;\n  }\n\n  server.on(\"error\", cb);\n  server.listen(options.port, options.host, cb);\n};\n\nexports.close = function() {\n  try {\n    server.close();\n  } catch (ex) {\n  }\n};\n\nfunction processRequest(req, res) {\n  var qsIdx, qs, question;\n  try {\n    cservice.log(\n      \"API: \"\n      + req.url.replace(/accessKey=.*/i, \"accessKey={ACCESS_KEY}\").data\n    );\n\n    if (req.url.indexOf(\"/cli?\") !== 0) {\n      res.writeHead(404);\n      res.end(\"Page Not Found\");\n      return;\n    }\n\n    if (req.method !== \"POST\" && cservice.options.allowHttpGet !== true) {\n      res.writeHead(405);\n      res.end(\"Method Not Allowed\");\n      return;\n    }\n\n    qsIdx = req.url.indexOf(\"?\");\n\n    qs = querystring.parse(req.url.substr(qsIdx + 1));\n    if (!qs.accessKey || qs.accessKey !== options.accessKey) {\n      res.writeHead(401);\n      res.end(\"Not authorized\");\n      return;\n    }\n\n    question = qs.cmd || \"\";\n\n    req.on('data', function (chunk) {\n      question += chunk;\n    });\n\n    req.on('end', function () {\n      onCommand(req, res, question, qs.accessKey);\n    });\n  } catch (ex) {\n    cservice.error(\n      \"Woops, an ERROR!\".error,\n      util.inspect(ex, {depth: null}),\n      util.inspect(ex.stack || new Error().stack, {depth: null})\n    );\n  }\n}\n\nfunction onCommand(req, res, question, accessKey) {\n  var args = require(\"./util\").getArgsFromQuestion(question, \" \");\n  var controlLevel;\n  var isAuthorized;\n\n  args = [args[0], function(err, result) {\n      onCallback(req, res, err, result);\n    }].concat(args.slice(1));\n\n  if (!cservice.locals.events[args[0]]) {\n    cservice.error(\"Command \" + (args[0] + \"\").cyan + \" not found\".error);\n    res.writeHead(404);\n    res.end(\"Not found. Try /help\");\n    return;\n  }\n\n  controlLevel = control.levels.remote;\n  if (req.connection.remoteAddress === \"127.0.0.1\") {\n    controlLevel = control.levels.local;\n  }\n\n  isAuthorized = control.authorize(args[0], controlLevel, accessKey);\n\n  if (!isAuthorized) {\n    res.writeHead(401);\n    res.end(\"Not authorized to execute '\" + args[0] + \"' remotely\");\n    return;\n  }\n\n  try {\n    cservice.trigger.apply(null, args);\n  } catch (ex) {\n    res.writeHead(400);\n    res.end(JSON.stringify(\n      {\n        ex: ex,\n        stack: ex.stack || new Error().stack,\n        more: \"Error. Try /help\"\n      }\n    ));\n  }\n}\n\nfunction onCallback(req, res, err, result) {\n  var body;\n  try {\n    delete cservice.locals.reason;\n\n    if (err) { // should do nothing if response already sent\n      res.writeHead(400);\n      res.end(err);\n    } else {\n      if (result) {\n        try\n        {\n          body = JSON.stringify(result, function(key, val) {\n            if (key[0] === \"_\") {\n              return undefined;\n            } else {\n              return val;\n            }\n          });\n          res.writeHead(\n            200,\n            {\n              \"Content-Type\": \"text/json; charset=UTF-8\",\n              \"Content-Length\": Buffer.byteLength(body)\n            }\n          );\n          res.end(body);\n        } catch (ex) {\n          err = util.inspect(ex, {depth: null});\n          res.writeHead(400);\n          res.end(JSON.stringify({error: err}));\n          cservice.error(\n            \"Woops, an ERROR!\".error,\n            err,\n            util.inspect(ex.stack || new Error().stack, {depth: null})\n          );\n        }\n      } else {\n        res.writeHead(200);\n        res.end(\"No data\");\n      }\n    }\n  } catch (ex) {\n    cservice.error(\n      \"Woops, an ERROR!\".error,\n      util.inspect(ex, {depth: null}),\n      util.inspect(ex.stack || new Error().stack, {depth: null})\n    );\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/legacy.js":"var cservice = require(\"../cluster-service\");\n\nmodule.exports = exports = legacySupport;\n\nfunction legacySupport(options) {\n  if (options.worker) {\n    cservice.log(\n      \"Option `worker` has been deprecated. Use `workers` instead.\".warn\n    );\n    options.workers = options.worker;\n    delete options.worker;\n  }\n}\n\nlegacySupport(cservice.options);\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/master.js":"/* jshint loopfunc:true */\nvar cservice = require(\"../cluster-service\"),\n  cluster = require(\"cluster\"),\n  httpserver = require(\"./http-server\"),\n  async = require(\"async\"),\n  path = require(\"path\"),\n  startRequests = []; // queued start requests\n\nexports.start = startMaster;\n\nfunction startMaster(options, cb) {\n  var workersRemaining;\n  var workersForked;\n  var workers;\n  var i;\n  var workerName;\n  var worker;\n  var workerCount;\n\n  options = options || {};\n  options.workerCount = options.workerCount || 1;\n\n  if (cservice.locals.state === 0) { // one-time initializers\n    cservice.locals.state = 1; // starting\n\n    require(\"./commands/version\")({}, function(err, ver) {\n      cservice.log(\"cluster-service v\".info + ver.data + \" starting...\".info);\n    });\n\n    /*process.on(\"uncaughtException\", function(err) {\n     cservice.log(\"uncaughtException\", util.inspect(err));\n     });*/\n\n    // queue up our request\n    startRequests.push(function() {\n      startMaster(options, cb);\n    });\n\n    startListener(options, function(err) {\n      var i;\n      if (err) {\n        cservice.locals.isAttached = true;\n\n        // start the http client\n        require(\"./http-client\").init(options);\n      } else { // we're the single-master\n        cservice.locals.isAttached = false;\n\n        cluster.setupMaster({silent: (options.silent === true)});\n\n        cluster.on(\"online\", function(worker) {\n          cservice.trigger(\"workerStart\", worker);\n        });\n        cluster.on(\"exit\", function(worker, code, signal) {\n          // stop tracking\n          var version = cservice.locals.proxy.versions[worker.cservice.version];\n          if (version) {\n            // get all proxy workers for a specific version\n            var versionWorkers =\n              cservice.proxy.getVersionWorkers(worker.cservice.version);\n            // exclude our exiting worker process in case it's still returned\n            versionWorkers = versionWorkers.filter(function(versionWorker) {\n              return worker.process.pid !== versionWorker.process.pid;\n            });\n\n            if (versionWorkers.length === 0) {\n              // if no workers remain for a given version, drop the version\n              delete cservice.locals.proxy.versions[worker.cservice.version];\n\n              // inform proxy workers of version change\n              cservice.proxy.updateProxyWorkers();\n            }\n          }\n          delete cservice.locals.workerProcesses[worker.process.pid];\n\n          cservice.trigger(\"workerExit\", worker);\n          // do not restart if there is a reason, or disabled\n          if (\n            !(cservice.locals.reason || worker.cservice.reason)\n            && worker.suicide !== true\n            && cservice.locals.restartOnFailure === true\n          ) {\n            setTimeout(function() {\n              // lets replace lost worker.\n              cservice.newWorker(worker.cservice);\n            }, options.restartDelayMs);\n          }\n        });\n\n        // start monitor\n        monitorWorkers();\n\n        if (options.cli === true) {\n          // wire-up CLI\n          require(\"./cli\").init(options);\n        }\n      }\n\n      cservice.proxy.start({}, function() {\n        cservice.locals.state = 2; // running\n\n        // now that listener is ready, process queued start requests\n        for (i = 0; i < startRequests.length; i++) {\n          startRequests[i](); // execute\n        }\n        startRequests = [];\n      });\n    });\n  } else if (cservice.locals.state === 1) { // if still starting, queue requests\n    startRequests.push(function() {\n      startMaster(options, cb);\n    });\n  // if we're NOT attached, we can spawn the workers now\n  } else if (cservice.locals.isAttached === false) {\n    // fork it, i'm out of here\n    workersRemaining = 0;\n    workersForked = 0;\n\n    if (options.workers !== null) {\n      workers = typeof options.workers === \"string\"\n        ? {main: {worker: options.workers}}\n        : options.workers;\n      for (workerName in workers) {\n        worker = workers[workerName];\n        workerCount = worker.count || options.workerCount;\n        workersRemaining += workerCount;\n        workersForked += workerCount;\n        for (i = 0; i < workerCount; i++) {\n          cservice.newWorker(worker, function(err) {\n            workersRemaining--;\n            if (err) {\n              workersRemaining = 0; // callback now\n            }\n            if (workersRemaining === 0) {\n              if (typeof options.master === \"string\") {\n                require(path.resolve(options.master));\n              }\n              if(cb){\n                cb(err);\n              }\n            }\n          });\n        }\n      }\n    }\n\n    // if no forking took place, make sure cb is invoked\n    if (workersForked === 0) {\n      cservice.log(\"No workers running. Try 'start server.js'.\".info);\n      if(cb){\n        cb();\n      }\n    }\n  } else { // nothing else to do\n    if(cb){\n      cb();\n    }\n  }\n}\n\nfunction startListener(options, cb) {\n  if (typeof options.accessKey === \"undefined\") { // in-proc mode only\n    cservice.log(\n      [\n        \"LOCAL ONLY MODE. Run with 'accessKey' option to enable communication\",\n        \"channel.\"\n      ]\n      .join(' ')\n      .info\n      );\n    cb();\n    return;\n  } else {\n    options.accessKey = options.accessKey.toString();\n    require(\"./control\").setAccessKey(options.accessKey);\n  }\n\n  httpserver.init(options, function(err) {\n    if (!err) {\n      cservice.log(\n        (\"Listening at \"\n          + (\n            (options.ssl ? \"https://\" : \"http://\")\n            + options.host\n            + \":\"\n            + options.port\n            + \"/cli\"\n            )\n          .data\n          )\n        .info\n        );\n    }\n\n    cb(err);\n  });\n}\n\nfunction monitorWorkers() {\n  if (cservice.options.restartOnMemUsage || cservice.options.restartOnUpTime) {\n    setTimeout(onMonitorWorkers, 20000).unref(); // do not hold server open\n  }\n}\n\nfunction onMonitorWorkers() {\n  cservice.trigger(\"workers\", function(err, results) {\n    var workers;\n    var restarts;\n    var memUsage;\n    var upTime;\n    var i;\n    var w;\n\n    if (err || !results || !results.workers) {\n      // nothing we can do about it at this time\n      setTimeout(onMonitorWorkers, 60000).unref(); // do not hold server open\n      return;\n    }\n    workers = results.workers;\n    restarts = [];\n    memUsage = cservice.options.restartOnMemUsage;\n    upTime = cservice.options.restartOnUpTime;\n    for (i = 0; i < workers.length; i++) {\n      w = workers[i];\n      if (\n        (memUsage && w.process.memory.rss > memUsage)\n        ||\n        (upTime && w.process.uptime > upTime)\n        ) {\n        restarts.push(getWorkerToRestart(w));\n      }\n    }\n    if (restarts.length > 0) {\n      async.series(restarts, function(err, results) {\n        setTimeout(onMonitorWorkers, 20000).unref(); // do not hold server open\n      });\n    } else {\n      setTimeout(onMonitorWorkers, 30000).unref(); // do not hold server open\n    }\n  }, \"simple\");\n}\n\nfunction getWorkerToRestart(worker) {\n  return function(cb) {\n    cservice.trigger(\"restart\", cb, worker.pid);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/proxy-worker.js":"var cservice = require(\"../cluster-service\");\nvar cluster = require(\"cluster\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar httpProxy = require('http-proxy');\nvar msgBus = require('./message-bus');\n\ncservice.workerReady(false);\n\nvar proxy = httpProxy.createProxyServer({});\nvar versionHeader = cluster.worker.env.versionHeader;\nvar versionPath = cluster.worker.env.versionPath;\nvar bindingInfo = JSON.parse(cluster.worker.env.bindingInfo);\nvar workerFilename = cluster.worker.env.workerFilename;\nvar waiters = {};\ncservice.locals.proxy.defaultVersion = null; // default not set til online\n\n// set initial versions based on state provided by master\ncservice.locals.proxy.versions = JSON.parse(cluster.worker.env.versions);\n\nvar proxyServer;\n\nif (bindingInfo.tlsOptions) {\n  // https\n\n  if (typeof bindingInfo.tlsOptions.key === \"string\") {\n    bindingInfo.tlsOptions.key = fs.readFileSync(bindingInfo.tlsOptions.key);\n  }\n  if (typeof bindingInfo.tlsOptions.cert === \"string\") {\n    bindingInfo.tlsOptions.cert = fs.readFileSync(bindingInfo.tlsOptions.cert);\n  }\n  if (typeof bindingInfo.tlsOptions.pem === \"string\") {\n    bindingInfo.tlsOptions.pem = fs.readFileSync(bindingInfo.tlsOptions.pem);\n  }\n\n  proxyServer = require(\"https\").createServer(\n    bindingInfo.tlsOptions, proxyServerRequest\n  );\n} else {\n  // http\n\n  proxyServer = require(\"http\").createServer(proxyServerRequest);\n}\n\nprocess.on(\"message\", onMessageFromMaster);\n\nfunction proxyServerRequest(req, res) {\n  var versionStr = req.headers[versionHeader] ||\n    cservice.locals.proxy.options.defaultVersion\n  ;\n\n  getProxyVersion(versionStr, function (err, version) {\n    if (err) {\n      cservice.log(\"Failed to load proxy version \" + versionStr, err);\n\n      // todo: add option to set 404 content\n      // via options.customResponses[404] file\n      res.writeHead(404);\n      return void res.end(\"Not found\");\n    }\n    proxy.web(req, res, { target: \"http://127.0.0.1:\" + version.port });\n  });\n}\n\nproxyServer.listen(bindingInfo.port, cservice.workerReady);\n\nfunction getProxyVersion(versionStr, cb) {\n  var version = cservice.locals.proxy.versions[versionStr];\n  if (version) {\n    updateVersionLastAccess(version);\n    return waitForVersionToComeOnline(versionStr, cb);\n  }\n\n  // version not found, lets start it\n  cservice.trigger(\"proxy\", function(err, result) {\n    if (err) {\n      return cb(err);\n    }\n\n    // return newly started version\n    waitForVersionToComeOnline(versionStr, cb);\n  }, \"version\", versionStr);\n}\n\nfunction waitForVersionToComeOnline(versionStr, cb) {\n  var version = cservice.locals.proxy.versions[versionStr];\n  if (version && version.online === true) {\n    return cb(null, version); // ready!\n  }\n\n  // try waiting\n  var timer, attempts = 0;\n  timer = setInterval(function() {\n    version = cservice.locals.proxy.versions[versionStr];\n    if (version && version.online === true) {\n      clearInterval(timer);\n      return cb(null, version);\n    }\n    attempts++;\n    if (attempts > 240) {\n      clearInterval(timer);\n      return cb(\"Timed out waiting for version to come online!\");\n    }\n  }, 250);\n  timer.unref();\n}\n\nfunction onMessageFromMaster(msg) {\n  if (!msgBus.isValidMessage(msg)) return;\n\n  switch (msg.cservice.cmd) {\n    case \"proxyVersions\":\n      // update versions state\n      cservice.locals.proxy.versions = msg.cservice.versions;\n      cservice.locals.proxy.options.defaultVersion =\n        msg.cservice.defaultVersion\n      ;\n\n      // update version for default port mapping\n      cservice.locals.proxy.defaultVersion =\n        cservice.locals.proxy.versions[msg.cservice.defaultVersion]\n      ;\n\n      break;\n  }\n}\n\nfunction updateVersionLastAccess(version) {\n  var now = Date.now();\n  var diff = now - version.lastAccess;\n  if (diff >= 0 && diff < 5000) {\n    return; // if less than 5 seconds since last access,\n            // don't bother updating master\n  }\n  version.lastAccess = now;\n  var msg = cservice.msgBus.createMessage(\"versionUpdateLastAccess\", {\n    version: version.name\n  });\n  cservice.processSafeSend(process, msg);\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/run.js":"var util = require(\"util\"),\n  http = require(\"http\"),\n  querystring = require(\"querystring\"),\n  options = null,\n  cservice = require(\"../cluster-service\");\n\nexports.start = function(o, cb) {\n  var cmd;\n  options = o;\n\n  cmd = options.run;\n  delete options.run;\n\n  run(cmd, cb);\n};\n\nfunction run(question, cb) {\n  var qs = querystring.stringify({\n    cmd: question,\n    accessKey: options.accessKey\n  });\n  var body = \"\", err;\n  var url = \"http://\"\n    + (options.host || \"localhost\")\n    + \":\"\n    + (options.port || 11987)\n    + \"/cli\"\n    + \"?\" + qs\n    ;\n  cservice.log(\n    \"Running remote command: \".warn\n    + url.replace(/accessKey=.*/i, \"accessKey={ACCESS_KEY}\").data\n    );\n  http.request({\n      host: options.host || \"localhost\",\n      port: options.port || 11987,\n      path: \"/cli?\" + qs,\n      method: \"POST\"\n    }\n    , function(res) {\n      res.setEncoding('utf8');\n      res.on(\"data\", function(chunk) {\n        body += chunk;\n      });\n      res.on(\"end\", function() {\n        if (res.statusCode !== 200 && body) {\n          err = body;\n        }\n        if (err) {\n          cservice.error(\"Error: \", err);\n          body = {statusCode: res ? res.statusCode : \"no response\", error: err};\n        } else if (\n          typeof body === \"string\"\n          && (\n            body.indexOf(\"{\") === 0\n            || body.indexOf(\"[\") === 0\n            )\n          ) {\n          body = JSON.parse(body); // deserialize\n        }\n        if (options.json === true) {\n          cservice.results(JSON.stringify(body));\n        } else {\n          cservice.results(util.inspect(body, {depth: null, colors: true}));\n        }\n\n        if (cb) {\n          cb(err, body);\n        }\n      });\n    }\n  ).on(\n    \"error\"\n    , function(err) {\n      body = err;\n\n      if (options.json === true) {\n        cservice.results(JSON.stringify(body));\n      } else {\n        cservice.results(util.inspect(body, {depth: null, colors: true}));\n      }\n\n      if (cb) {\n        cb(err, body);\n      }\n    }\n  )\n  .end();\n}\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/scripts/start.js":"require(\"../cluster-service\").start();\n","/home/travis/build/npmtest/node-npmtest-cluster-service/node_modules/cluster-service/lib/cli.js":"var cservice = require(\"../cluster-service\"),\n  util = require(\"util\"),\n  options = null;\n\nexports.init = function(o) {\n  options = o;\n\n  util.inspect.styles.name = \"grey\";\n\n  cservice.log(\n    \"CLI is now available. Enter 'help [enter]' for instructions.\".info\n  );\n  process.stdin.resume();\n  process.stdin.setEncoding('utf8');\n\n  process.stdin.on(\"data\", onCommand);\n\n  // wait momentarily before attaching CLI. allows workers a little time \n  // to output as needed\n  setTimeout(function() {\n    process.stdout.write(\"cservice> \".cservice);\n  }, 1000);\n};\n\nexports.close = function() {\n  try {\n    process.stdin.pause();\n  } catch (ex) {\n  }\n};\n\nfunction onCommand(question) {\n  if (cservice.locals.isBusy === true) {\n    cservice.error(\"Busy... Try again after previous command returns.\");\n    return;\n  }\n\n  cservice.locals.isBusy = true;\n  \n  var args;\n  question = question.replace(/[\\r\\n]/g, \"\");\n  args = require(\"./util\").getArgsFromQuestion(question, \" \");\n  args = [args[0], onCallback].concat(args.slice(1));\n\n  if (!cservice.locals.events[args[0]]) {\n    onCallback(\"Command \" + args[0] + \" not found. Try 'help'.\");\n\n    return;\n  }\n\n  try {\n    cservice.trigger.apply(null, args);\n  } catch (ex) {\n    cservice.error(\n      \"Command Error \" + args[0],\n      util.inspect(ex, {depth: null}), ex.stack || new Error().stack\n    );\n    onCallback();\n  }\n}\n\nfunction onCallback(err, result) {\n  delete cservice.locals.reason;\n\n  cservice.locals.isBusy = false;\n  \n  if (err) {\n    cservice.error(\n      \"Error: \",\n      err,\n      err.stack\n        ? util.inspect(err.stack, {depth: null, colors: true})\n        : \"\"\n    );\n  } else if (result) {\n    cservice.log(util.inspect(result, {depth: null, colors: true}));\n  }\n\n  //cservice.log(\"\");//newline\n\n  process.stdout.write(\"cservice> \".cservice);\n}\n"}